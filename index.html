<!DOCTYPE html>
<!--
=============================================================================
                            PDF READER FOR BLOGGER
=============================================================================

OVERVIEW:
This is a client-side PDF reader designed for embedding in Blogger posts.
It uses PDF.js to render PDFs with features like bookmarking, break ads,
exit modals, and analytics tracking.

CONFIGURATION INSTRUCTIONS:
1. Replace PDF_URL with your actual PDF URL (line ~285)
2. Customize the book configuration and settings
3. Update BOOK_CONFIG with your book details (lines ~294-302)
4. Customize the break ad HTML content (line ~300)
5. Implement your analytics in the analyticsCallback function (lines ~305-309)

EMBEDDING IN BLOGGER:
Method 1 - Direct HTML:
1. Go to your Blogger post editor
2. Switch to HTML view
3. Copy and paste this entire file content
4. Publish your post

Method 2 - iframe (Recommended):
1. Host this file on a static hosting service (GitHub Pages, Netlify, etc.)
2. In your Blogger post, add:
   <iframe src="https://your-domain.com/reader.html" 
           width="100%" height="600px" frameborder="0">
   </iframe>

FEATURES:
‚úì PDF.js integration for client-side PDF rendering
‚úì Responsive design with mobile support
‚úì Top bar with Back button, Title, and Settings
‚úì Bottom toolbar with navigation, zoom, and fullscreen
‚úì localStorage bookmarking (saves last page and zoom)
‚úì Break ads with configurable intervals
‚úì Exit modal with download options
‚úì Analytics callback system
‚úì Keyboard navigation support
‚úì Accessibility features with ARIA labels
‚úì Urdu font support (Noto Nastaliq)
‚úì Graceful popup blocking fallback

KEYBOARD SHORTCUTS:
- Arrow Left/Page Up: Previous page
- Arrow Right/Page Down/Space: Next page
- Home: Go to first page
- End: Go to last page
- +/=: Zoom in
- -: Zoom out
- F/F11: Toggle fullscreen
- Escape: Exit fullscreen or show exit modal

ANALYTICS EVENTS:
- reader_open: When reader initializes
- page_view: When user views a new page
- break_ad_shown: When break ad is displayed
- exit_prompt_shown: When exit modal is shown
- download_clicked: When download button is clicked

ACCEPTANCE TESTS:
1. ‚úì Loads PDF URL and displays first page
2. ‚úì Next/Prev buttons change pages and fire page_view events
3. ‚úì Bookmark restores last page on reopen (localStorage)
4. ‚úì Break ad appears after configured pages and blocks navigation
5. ‚úì Exit modal functions with Continue/Download/Exit options
6. ‚úì Settings dropdown with theme modes and share functionality
7. ‚úì Easy to embed in Blogger with clear configuration placeholders

CUSTOMIZATION:
- Modify CSS variables for theming
- Update break ad interval and content
- Customize analytics implementation
- Add additional settings functionality
- Modify keyboard shortcuts as needed

DEPENDENCIES:
- PDF.js (loaded from CDN)
- Google Fonts (Noto Nastaliq Urdu)
- No server-side dependencies required

BROWSER SUPPORT:
- Chrome, Firefox, Safari, Edge
- Mobile browsers (iOS Safari, Chrome Mobile)

=============================================================================
-->
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
        <meta name="color-scheme" content="dark light">
        <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1a1a1a">
        <meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
        <title>PDF Reader</title>
        <link href="https://fonts.googleapis.com/css2?family=Noto+Nastaliq+Urdu:wght@400;700&display=swap" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            font-size: var(--font-size-md);
            line-height: 1.5;
        }

        .reader-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            position: relative;
        }

        .top-bar {
            background: linear-gradient(to bottom, rgba(255,255,255,0.08), rgba(255,255,255,0.02)), rgba(var(--bg-secondary-rgb), 0.60);
            backdrop-filter: blur(20px) saturate(160%);
            -webkit-backdrop-filter: blur(20px) saturate(160%);
            padding: calc(6px + env(safe-area-inset-top)) 10px 6px 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--border-light);
            position: relative;
            box-shadow: 0 1px 0 var(--border-light), 0 8px 24px rgba(0,0,0,0.25), inset 0 1px rgba(255,255,255,0.06);
            z-index: 100;
            height: var(--toolbar-top-height);
            transition: transform var(--transition-normal);
        }

        .top-bar.hidden {
            transform: translateY(-100%);
        }

        .top-bar-left {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
        }

        .top-bar-center {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            pointer-events: none;
        }

        .top-bar-right {
            display: flex;
            align-items: center;
            flex: 1;
            justify-content: flex-end;
        }

        .btn {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 14px;
            font-weight: var(--font-weight-medium);
            transition: all var(--transition-fast);
            display: flex;
            align-items: center;
            gap: 6px;
            box-shadow: 0 1px 3px var(--shadow-light);
            position: relative;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            min-height: 32px;
        }

        .btn:hover {
            background: var(--accent-hover);
            box-shadow: 0 2px 8px var(--shadow-medium);
            transform: translateY(-1px);
        }

        .btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px var(--shadow-light);
        }

        .btn:focus {
            outline: none;
            box-shadow: 0 0 0 3px var(--accent-light);
        }

        /* Button variants */
        .btn-secondary {
            background: var(--bg-quaternary);
            color: var(--text-primary);
        }

        .btn-secondary:hover {
            background: var(--border-color);
        }

        .btn-ghost {
            background: transparent;
            color: var(--text-secondary);
            box-shadow: none;
        }

        .btn-ghost:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .book-title {
            font-size: var(--font-size-md);
            font-weight: var(--font-weight-semibold);
            color: var(--text-primary);
            max-width: clamp(160px, 40vw, 300px);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            text-align: center;
        }
        /* Compact toolbar button sizing (desktop/tablet) */
        .top-bar .btn,
        .bottom-toolbar .btn {
            padding: 3px 8px;
            min-height: 28px;
            font-size: 13px;
            border-radius: var(--radius-sm);
            gap: 4px;
        }

        .pdf-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
            background: var(--bg-tertiary);
            position: relative;
            height: calc(100dvh - var(--toolbar-top-height) - var(--toolbar-bottom-height));
            padding-bottom: env(safe-area-inset-bottom);
        }

        #pdf-canvas {
            display: block;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            cursor: grab;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            will-change: transform;
        }

        #pdf-canvas.zooming {
            transition: all 0.15s cubic-bezier(0.4, 0.0, 0.2, 1);
        }

        /* Touch feedback and modern interactions */
        .btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.3s, height 0.3s;
            pointer-events: none;
        }

        .btn:active::after {
            width: 120%;
            height: 120%;
        }

        /* Improved visual hierarchy */
        .toolbar-section {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            padding: var(--space-xs);
            border-radius: var(--radius-md);
            background: var(--bg-tertiary);
            border: 1px solid var(--border-light);
        }

        /* Enhanced focus states for accessibility */
        .btn:focus-visible,
        .page-input:focus-visible {
            outline: 2px solid var(--accent-color);
            outline-offset: 2px;
        }

        /* Smooth state transitions */
        .reader-container * {
            transition: background-color var(--transition-fast), 
                       border-color var(--transition-fast),
                       color var(--transition-fast);
        }

        #pdf-canvas:active {
            cursor: grabbing;
        }

        .canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-width: 100%;
            min-height: 100%;
        }

        .bottom-toolbar {
            background: linear-gradient(to top, rgba(255,255,255,0.06), rgba(255,255,255,0.02)), rgba(var(--bg-secondary-rgb), 0.60);
            backdrop-filter: blur(20px) saturate(160%);
            -webkit-backdrop-filter: blur(20px) saturate(160%);
            padding: 6px 10px calc(6px + env(safe-area-inset-bottom)) 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            border-top: 1px solid var(--border-light);
            box-shadow: 0 -1px 0 var(--border-light), 0 -8px 24px rgba(0,0,0,0.25), inset 0 1px rgba(255,255,255,0.06);
            z-index: 100;
            height: var(--toolbar-bottom-height);
            transition: transform var(--transition-normal);
        }

        .bottom-toolbar.hidden {
            transform: translateY(100%);
        }

        /* Glass overlay highlight */
        .top-bar::before,
        .bottom-toolbar::before {
            content: '';
            position: absolute;
            inset: 0;
            pointer-events: none;
            background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
        }

        .toolbar-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .toolbar-center {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .toolbar-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .page-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .page-input {
            width: 45px;
            padding: 4px 8px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            text-align: center;
            font-size: 14px;
            font-weight: var(--font-weight-medium);
            transition: all var(--transition-fast);
            outline: none;
            height: 32px;
        }

        .page-input:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px var(--accent-light);
            background: var(--bg-secondary);
        }

        .page-input:hover {
            border-color: var(--text-tertiary);
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .zoom-display {
            min-width: 60px;
            text-align: center;
            font-size: var(--font-size-sm);
            font-weight: var(--font-weight-medium);
            color: var(--text-secondary);
            background: var(--bg-tertiary);
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
        }

        .reading-progress {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
            transition: opacity 0.3s ease;
        }

        .reading-progress.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .progress-info {
            display: flex;
            gap: 10px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .loading {
            font-size: var(--font-size-lg);
            font-weight: var(--font-weight-medium);
            color: var(--text-secondary);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-lg);
            padding: var(--space-xxl);
        }

        .loading::before {
            content: '';
            width: 48px;
            height: 48px;
            border: 4px solid var(--border-color);
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-progress {
            width: 200px;
            height: 4px;
            background: var(--border-color);
            border-radius: 2px;
            overflow: hidden;
            margin-top: var(--space-md);
        }

        .loading-progress::after {
            content: '';
            display: block;
            width: 40%;
            height: 100%;
            background: var(--accent-color);
            border-radius: 2px;
            animation: loadingProgress 2s ease-in-out infinite;
        }

        @keyframes loadingProgress {
            0% { transform: translateX(-100%); }
            50% { transform: translateX(250%); }
            100% { transform: translateX(-100%); }
        }

        .error-state {
            color: var(--error-color);
            text-align: center;
            padding: var(--space-xxl);
        }

        .error-state .error-icon {
            font-size: 48px;
            margin-bottom: var(--space-lg);
        }

        .error-state .error-message {
            font-size: var(--font-size-lg);
            font-weight: var(--font-weight-medium);
            margin-bottom: var(--space-md);
        }

        .error-state .error-details {
            font-size: var(--font-size-sm);
            color: var(--text-tertiary);
            margin-bottom: var(--space-lg);
        }

        /* Keyboard shortcut styling */
        kbd {
            background: var(--bg-quaternary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            padding: 2px 6px;
            font-family: monospace;
            font-size: var(--font-size-xs);
            font-weight: var(--font-weight-semibold);
            color: var(--text-primary);
            box-shadow: 0 1px 2px var(--shadow-light);
        }

        /* Notification system */
        .notification {
            position: fixed;
            top: 80px;
            right: var(--space-lg);
            background: var(--bg-secondary);
            color: var(--text-primary);
            padding: var(--space-sm) var(--space-md);
            border-radius: var(--radius-lg);
            box-shadow: 0 4px 20px var(--shadow-medium);
            border: 1px solid var(--border-color);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            z-index: 1000;
            transform: translateX(120%);
            transition: transform var(--transition-normal);
            font-size: var(--font-size-sm);
            font-weight: var(--font-weight-medium);
            max-width: 300px;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            border-left: 4px solid var(--success-color);
        }

        .notification.error {
            border-left: 4px solid var(--error-color);
        }

        .notification.info {
            border-left: 4px solid var(--accent-color);
        }

        /* Enhanced back button styling */
        .btn[aria-label="Go back"] {
            position: relative;
            overflow: hidden;
            transition: all var(--transition-normal);
        }

        .btn[aria-label="Go back"]:hover {
            transform: translateX(-2px);
            box-shadow: 2px 0 8px var(--shadow-medium);
        }

        .btn[aria-label="Go back"]:active {
            transform: translateX(-1px);
        }

        /* Back button loading state */
        .btn[aria-label="Go back"].loading {
            opacity: 0.7;
            pointer-events: none;
        }

        .btn[aria-label="Go back"].loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 16px;
            height: 16px;
            margin: -8px 0 0 -8px;
            border: 2px solid transparent;
            border-top: 2px solid currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Theme Variations */
        .theme-light {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #e9ecef;
            --bg-quaternary: #dee2e6;
            
            --text-primary: #212529;
            --text-secondary: #495057;
            --text-tertiary: #6c757d;
            
            --accent-color: #0066cc;
            --accent-hover: #0052a3;
            --accent-light: rgba(0, 102, 204, 0.1);
            
            --border-color: #dee2e6;
            --border-light: #e9ecef;
            
            --shadow-light: rgba(0, 0, 0, 0.05);
            --shadow-medium: rgba(0, 0, 0, 0.1);
            --shadow-heavy: rgba(0, 0, 0, 0.15);
        }

        .theme-blue {
            --bg-primary: #0f1419;
            --bg-secondary: #1e2328;
            --bg-tertiary: #2d3338;
            --bg-quaternary: #3c4348;
            
            --text-primary: #e6f1ff;
            --text-secondary: #b3d9ff;
            --text-tertiary: #80c1ff;
            
            --accent-color: #00d4ff;
            --accent-hover: #00b8e6;
            --accent-light: rgba(0, 212, 255, 0.2);
            
            --border-color: #3c4348;
            --border-light: #4d5358;
        }

        .theme-green {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --bg-quaternary: #30363d;
            
            --text-primary: #f0f6fc;
            --text-secondary: #c9d1d9;
            --text-tertiary: #8b949e;
            
            --accent-color: #238636;
            --accent-hover: #2ea043;
            --accent-light: rgba(35, 134, 54, 0.2);
            
            --border-color: #30363d;
            --border-light: #21262d;
        }

        .theme-purple {
            --bg-primary: #1a0d1a;
            --bg-secondary: #2d1b2d;
            --bg-tertiary: #3a2a3a;
            --bg-quaternary: #4a394a;
            
            --text-primary: #f0e6f0;
            --text-secondary: #d9b3d9;
            --text-tertiary: #c280c2;
            
            --accent-color: #8b5cf6;
            --accent-hover: #7c3aed;
            --accent-light: rgba(139, 92, 246, 0.2);
            
            --border-color: #4a394a;
            --border-light: #5a495a;
        }

        .progress-percentage {
            font-weight: bold;
            color: var(--accent-color);
        }

        .time-estimate {
            color: var(--text-secondary);
        }

        .progress-bar-container {
            width: 120px;
            height: 4px;
            background: var(--border-color);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: var(--accent-color);
            width: 0%;

/* Modal Styles */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 2000;
    padding: var(--space-lg);
}

.modal-content {
    background: var(--bg-secondary);
    padding: var(--space-xl);
    border-radius: var(--radius-xl);
    text-align: center;
    max-width: 480px;
    width: 100%;
    box-shadow: 0 20px 60px var(--shadow-heavy);
    border: 1px solid var(--border-color);
    animation: modalSlideIn 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
}

@keyframes modalSlideIn {
    from {
        opacity: 0;
        transform: translateY(20px) scale(0.95);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

.modal-content h3 {
    margin-bottom: var(--space-lg);
    color: var(--text-primary);
    font-size: var(--font-size-xl);
    font-weight: var(--font-weight-semibold);
}

.modal-buttons {
    display: flex;
    gap: var(--space-md);
    justify-content: center;
    margin-top: var(--space-xl);
    flex-wrap: wrap;
}
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 999;
        }

        .break-ad-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            color: black;
            padding: 20px;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
            text-align: center;
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            font-size: 18px;
        }

        /* Settings Dropdown */
        .settings-container {
            position: relative;
            display: inline-block;
        }

        .settings-dropdown {
            position: absolute;
            top: calc(100% + var(--space-xs));
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            min-width: 200px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
            z-index: 1000;
            box-shadow: 0 8px 32px var(--shadow-heavy);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            scrollbar-width: thin;
            scrollbar-color: var(--accent-color) var(--bg-tertiary);
        }
        
        .settings-dropdown::-webkit-scrollbar {
            width: 6px;
        }
        
        .settings-dropdown::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 3px;
        }
        
        .settings-dropdown::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 3px;
        }

        .settings-dropdown.show {
            display: block;
            animation: dropdownSlideIn 0.2s cubic-bezier(0.4, 0.0, 0.2, 1);
        }

        @keyframes dropdownSlideIn {
            from {
                opacity: 0;
                transform: translateY(-8px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .dropdown-item {
            padding: var(--space-md) var(--space-lg);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            border-bottom: 1px solid var(--border-light);
            font-size: var(--font-size-sm);
            font-weight: var(--font-weight-medium);
            color: var(--text-secondary);
            transition: all var(--transition-fast);
            position: relative;
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        .dropdown-item:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .dropdown-item.active {
            background: var(--accent-light);
            color: var(--accent-color);
        }

        .dropdown-item.active::after {
            content: '‚úì';
            position: absolute;
            right: var(--space-md);
            color: var(--accent-color);
            font-weight: var(--font-weight-bold);
        }

        /* Modern Design System */
        :root {
            /* Default Dark Theme */
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3a3a3a;
            --bg-quaternary: #4a4a4a;
            
            /* Toolbar sizes and RGB tokens */
            --toolbar-top-height: 45px;
            --toolbar-bottom-height: 45px;
            --bg-secondary-rgb: 45, 45, 45;
            
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --text-tertiary: #999999;
            
            --accent-color: #007acc;
            --accent-hover: #005a9e;
            --accent-light: rgba(0, 122, 204, 0.2);
            
            --border-color: #444444;
            --border-light: #555555;
            
            --success-color: #28a745;
            --error-color: #dc3545;
            --warning-color: #ffc107;
            
            --shadow-light: rgba(0, 0, 0, 0.1);
            --shadow-medium: rgba(0, 0, 0, 0.2);
            --shadow-heavy: rgba(0, 0, 0, 0.3);
            
            /* Spacing System */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 16px;
            --space-lg: 24px;
            --space-xl: 32px;
            --space-xxl: 48px;
            
            /* Border Radius */
            --radius-sm: 6px;
            --radius-md: 8px;
            --radius-lg: 12px;
            --radius-xl: 16px;
            
            /* Typography */
            --font-size-xs: 12px;
            --font-size-sm: 14px;
            --font-size-md: 16px;
            --font-size-lg: 18px;
            --font-size-xl: 20px;
            --font-weight-normal: 400;
            --font-weight-medium: 500;
            --font-weight-semibold: 600;
            --font-weight-bold: 700;
            
            /* Transitions */
            --transition-fast: 0.15s cubic-bezier(0.4, 0.0, 0.2, 1);
            --transition-normal: 0.25s cubic-bezier(0.4, 0.0, 0.2, 1);
            --transition-slow: 0.35s cubic-bezier(0.4, 0.0, 0.2, 1);
            
            /* Inform UA about supported color schemes */
            color-scheme: dark light;
        }

        /* Light Mode */
        body.light-mode {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #f1f3f4;
            --bg-quaternary: #e8eaed;
            --bg-secondary-rgb: 248, 249, 250;
            --text-primary: #1f2937;
            --text-secondary: #374151;
            --text-tertiary: #6b7280;
            --border-color: #e5e7eb;
            --border-light: #f3f4f6;
            --accent-color: #007aff;
            --accent-hover: #0056cc;
            --accent-light: rgba(0, 122, 255, 0.08);
            --shadow-light: rgba(0, 0, 0, 0.05);
            --shadow-medium: rgba(0, 0, 0, 0.1);
            --shadow-heavy: rgba(0, 0, 0, 0.15);
        }

        /* Focus Mode */
        body.focus-mode {
            background: #000;
        }

        body.focus-mode .top-bar,
        body.focus-mode .bottom-toolbar {
            transform: translateY(-100%);
            transition: transform 0.3s ease;
        }

        body.focus-mode .bottom-toolbar {
            transform: translateY(100%);
        }

        body.focus-mode .pdf-container {
            height: 100vh;
            background: #000;
            padding: 0;
        }

        body.focus-mode #canvas-container {
            max-width: none;
            max-height: none;
            padding: 0;
        }

        body.focus-mode #pdf-canvas {
            max-width: none;
            max-height: none;
        }

        body.focus-mode .exit-focus-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }

        body.focus-mode:hover .exit-focus-btn {
            opacity: 1;
        }

        body {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .top-bar, .bottom-toolbar {
            background: var(--bg-secondary);
            border-color: var(--border-color);
        }

        .pdf-container {
            background: var(--bg-tertiary);
        }

        .modal-content, .settings-dropdown {
            background: var(--bg-secondary);
            border-color: var(--border-color);
        }

        .modal h3 {
            color: var(--text-primary);
        }

        .page-input {
            background: var(--bg-tertiary);
            border-color: var(--border-color);
            color: var(--text-primary);
        }

        .btn {
            background: var(--accent-color);
        }

        .dropdown-item {
            border-color: var(--border-color);
            color: var(--text-primary);
        }

        /* Mobile-First Responsive Design */
        
        /* Base mobile styles (320px+) */
        @media (max-width: 768px) {
            :root {
                --toolbar-top-height: 40px;
                --toolbar-bottom-height: 60px;
            }
            body {
                max-width: 100%;
                width: 100%;
                overflow-x: hidden;
                -webkit-overflow-scrolling: touch;
            }

            .reader-container {
                width: 100%;
                overflow: hidden;
            }

            .top-bar, .bottom-toolbar {
                padding: 6px;
                height: auto;
                min-height: 45px;
                width: 100%;
                flex-wrap: wrap;
                gap: 6px;
            }

            .toolbar-left, 
            .toolbar-right {
                flex: 0 0 auto;
            }

            .toolbar-center {
                flex: 1 1 100%;
                order: 2;
                position: relative;
                left: 0;
                transform: none;
                justify-content: center;
            }

            .pdf-container {
                max-width: 100%;
                width: 100%;
                height: calc(100dvh - var(--toolbar-top-height) - var(--toolbar-bottom-height));
                padding-bottom: calc(env(safe-area-inset-bottom) + 12px);
                overflow-x: hidden;
            }

            #pdf-canvas {
                width: 100% !important;
                height: auto !important;
                touch-action: pan-y pinch-zoom;
            }

            .btn {
                font-size: 12px;
                padding: 4px 8px;
                min-height: 36px;
                min-width: 36px;
            }

            .settings-container {
                position: static;
            }

            .settings-dropdown {
                position: fixed;
                top: auto;
                bottom: 0;
                left: 0;
                right: 0;
                width: 100%;
                max-height: 80vh;
                border-radius: 16px 16px 0 0;
                margin: 0;
                transform: translateY(100%);
                transition: transform 0.3s ease;
                box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.2);
            }

            .settings-dropdown.show {
                transform: translateY(0);
            }

            .page-info {
                flex: 1;
                justify-content: center;
            }

            .page-input {
                width: 40px;
                padding: 4px;
                font-size: 12px;
            }

            .zoom-controls {
                display: none; /* Hide zoom controls on mobile */
            }

            .notification {
                left: 16px;
                right: 16px;
                transform: translateY(-100%);
            }

            .notification.show {
                transform: translateY(0);
            }

            /* Improve touch targets */
            .dropdown-item {
                padding: 12px 16px;
                min-height: 44px;
            }
            .bottom-toolbar {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                width: 100%;
                padding: 12px 12px calc(12px + env(safe-area-inset-bottom)) 12px;
                background: rgba(var(--bg-secondary-rgb), 0.75);
                backdrop-filter: blur(12px) saturate(160%);
                -webkit-backdrop-filter: blur(12px) saturate(160%);
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
                justify-content: space-between;
                align-items: center;
                min-height: 60px;
            }

            .toolbar-left, 
            .toolbar-center, 
            .toolbar-right {
                display: flex;
                justify-content: center;
                align-items: center;
                gap: 8px;
            }

            .toolbar-left {
                justify-content: flex-start;
            }

            .toolbar-right {
                justify-content: flex-end;
            }

            .page-info {
                display: flex;
                align-items: center;
                gap: 8px;
                justify-content: center;
                flex-wrap: nowrap;
                width: 100%;
            }

            .page-input {
                width: 45px;
                height: 40px;
                padding: 4px;
                font-size: 14px;
                text-align: center;
                border-radius: var(--radius-md);
                -webkit-appearance: none;
                appearance: none;
            }

            .btn {
                min-width: 40px;
                min-height: 40px;
                padding: 8px;
                border-radius: var(--radius-md);
                font-size: 14px;
                display: flex;
                align-items: center;
                justify-content: center;
                touch-action: manipulation;
            }

            .zoom-controls {
                display: none; /* Hide zoom controls on mobile */
            }

            /* Show only essential navigation on very small screens */
            @media (max-width: 380px) {
                .bottom-toolbar {
                    grid-template-columns: auto 1fr auto;
                    padding: 8px;
                }

                .page-info span {
                    display: none; /* Hide "of" text */
                }

                .btn {
                    min-width: 36px;
                    min-height: 36px;
                    padding: 6px;
                }
            }
            .reader-container {
                height: 100dvh; /* Use dynamic viewport height */
            }
            
            .top-bar {
                padding: 2px var(--space-xs);
                min-height: 32px; /* Further reduced mobile header height */
            }
            
            .top-bar-left, .top-bar-right {
                flex: 0 0 auto;
            }
            
            .book-title {
                max-width: 200px;
                font-size: var(--font-size-sm);
            }
            
            .bottom-toolbar {
                padding: 2px var(--space-xs);
                gap: 2px;
                flex-wrap: wrap;
                min-height: 36px; /* Further reduced height */
            }
            
            .toolbar-left, .toolbar-center, .toolbar-right {
                gap: var(--space-sm);
            }
            
            .toolbar-center {
                order: 3;
                flex-basis: 100%;
                justify-content: center;
                margin-top: var(--space-sm);
            }
            
            .btn {
                padding: var(--space-xs) var(--space-sm);
                font-size: var(--font-size-xs);
                min-width: 40px; /* Slightly smaller touch target */
                min-height: 40px;
                border-radius: var(--radius-md);
            }

            .settings-dropdown {
                min-width: 180px;
                right: 0;
                max-width: calc(100vw - var(--space-lg));
            }

            .reading-progress {
                margin-left: 0;
                font-size: var(--font-size-xs);
            }

            .progress-bar-container {
                width: 50px;
                height: 3px;
            }

            .progress-info {
                font-size: var(--font-size-xs);
                gap: var(--space-xs);
            }
            
            .page-input {
                width: 50px;
                font-size: var(--font-size-sm);
                min-height: 44px;
            }
            
            .zoom-display {
                min-width: 50px;
                font-size: var(--font-size-xs);
                min-height: 32px;
            }
            
            .zoom-controls {
                gap: var(--space-xs);
            }
            
            .zoom-controls .btn {
                width: 44px;
                height: 44px;
                padding: 0;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: var(--font-size-lg);
            }
            
            /* Canvas optimizations */
            #pdf-canvas {
                touch-action: pan-x pan-y pinch-zoom;
                max-width: 100%;
                max-height: 100%;
            }
            
            .canvas-container {
                padding: var(--space-sm);
            }
            
            /* Modal improvements */
            .modal {
                padding: var(--space-md);
            }
            
            .modal-content {
                padding: var(--space-lg);
                max-width: 100%;
                margin: var(--space-md);
            }
            
            .modal-buttons {
                flex-direction: column;
                gap: var(--space-sm);
            }
            
            .modal-buttons .btn {
                width: 100%;
                justify-content: center;
            }
        }
        
        /* Small mobile screens (480px and below) */
        @media (max-width: 480px) {
            .top-bar {
                padding: 2px var(--space-xs);
                min-height: 40px;
            }
            
            .toolbar-left {
                flex-wrap: wrap;
                gap: 2px;
            }
            
            .page-info {
                order: 2;
                flex-basis: 100%;
                justify-content: center;
                margin-top: 2px;
                gap: var(--space-xs);
            }
            
            .reading-progress {
                display: none; /* Hide on very small screens */
            }
            
            .book-title {
                max-width: 120px;
                font-size: var(--font-size-xs);
            }
            
            .bottom-toolbar {
                padding: 2px var(--space-xs);
                min-height: 44px;
            }
            
            .btn {
                font-size: var(--font-size-xs);
                padding: 2px var(--space-xs);
                min-height: 36px;
                min-width: 36px;
            }
            
            .settings-dropdown {
                min-width: 160px;
                font-size: var(--font-size-xs);
            }
            
            .toolbar-section {
                padding: 2px;
                gap: 2px;
            }
        }
        
        /* Large screens (1024px+) */
        @media (min-width: 1024px) {
            .top-bar {
                padding: var(--space-lg) var(--space-xxl);
            }
            
            .bottom-toolbar {
                padding: var(--space-lg) var(--space-xxl);
            }
            
            .book-title {
                max-width: 400px;
                font-size: var(--font-size-lg);
            }
            
            .btn {
                padding: var(--space-md) var(--space-lg);
                font-size: var(--font-size-md);
            }
            
            .settings-dropdown {
                min-width: 220px;
            }
        }
        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            .reader-container {
                height: 100dvh;
            }
            
            .top-bar {
                padding: 8px 12px;
                min-height: 48px;
            }
            
            .top-bar-left, .top-bar-right {
                gap: 8px;
            }
            
            .book-title {
                font-size: 14px;
                max-width: 200px;
            }
            
            .bottom-toolbar {
                padding: 8px;
                min-height: 56px;
                flex-wrap: wrap;
                gap: 8px;
                justify-content: center;
            }
            
            .toolbar-left, .toolbar-center, .toolbar-right {
                gap: 8px;
            }
            
            .toolbar-center {
                flex: 1 0 100%;
                order: -1;
                justify-content: center;
            }
            
            .btn {
                min-height: 44px;
                padding: 8px 12px;
                font-size: 16px;
                -webkit-tap-highlight-color: transparent;
            }

            .settings-dropdown {
                position: fixed;
                top: auto;
                bottom: 0;
                left: 0;
                right: 0;
                width: 100%;
                max-height: 80vh;
                border-radius: 16px 16px 0 0;
                padding: 16px 0;
            }

            .page-input {
                width: 50px;
                height: 44px;
                font-size: 16px;
                padding: 8px;
            }
            
            .zoom-display {
                min-width: 70px;
                padding: 8px 12px;
                font-size: 14px;
            }
            
            #pdf-canvas {
                max-width: 100% !important;
                height: auto !important;
                touch-action: pan-y pinch-zoom;
            }
            
            .canvas-container {
                width: 100%;
                overflow: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .modal {
                padding: 16px;
            }
            
            .modal-content {
                padding: 24px 16px;
                max-width: 100%;
                margin: 0 16px;
            }
            
            .modal-buttons {
                gap: 12px;
                flex-direction: column;
                padding: 0 16px;
            }
            
            .modal-buttons .btn {
                width: 100%;
                justify-content: center;
            }

            /* Touch optimizations */
            * {
                touch-action: manipulation;
            }

            .btn:active {
                transform: scale(0.96);
            }

            .pdf-container {
                scroll-behavior: smooth;
                -webkit-overflow-scrolling: touch;
                overscroll-behavior: contain;
            }

            /* Prevent text selection on interactive elements */
            .btn, .page-input, .book-title {
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                user-select: none;
            }

            /* Improved scrolling on Android */
            .pdf-container::-webkit-scrollbar {
                width: 6px;
                height: 6px;
            }

            .pdf-container::-webkit-scrollbar-thumb {
                background: var(--accent-color);
                border-radius: 3px;
            }

            /* Better touch targets */
            .dropdown-item {
                padding: 12px 16px;
                min-height: 48px;
            }

            /* Prevent pull-to-refresh */
            body {
                overscroll-behavior-y: contain;
            }

            /* Compact toolbar buttons on mobile */
            .top-bar .btn,
            .bottom-toolbar .btn {
                min-width: 36px;
                min-height: 36px;
                padding: 6px 8px;
                font-size: 13px;
                border-radius: var(--radius-sm);
            }
        }

        /* Small mobile screens (480px and below) */
        @media (max-width: 480px) {
            .top-bar-center {
                display: none;
            }

            .book-title {
                font-size: 13px;
                max-width: 150px;
            }

            .btn {
                padding: 8px;
                min-width: 44px;
            }

            .zoom-controls {
                display: none;
            }
        }
        /* Respect reduced motion preferences */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation: none !important;
                transition: none !important;
                scroll-behavior: auto !important;
            }
        }
    </style>
</head>
<body>
    <div class="reader-container">
        <!-- Top Bar -->
        <div class="top-bar">
            <div class="top-bar-left">
                <button class="btn" id="back-btn" aria-label="Go back">‚Üê Back</button>
            </div>
            <div class="top-bar-center">
                <div class="book-title" id="book-title">Loading PDF...</div>
            </div>
            <div class="top-bar-right">
                <div class="settings-container">
                    <button class="btn" id="settings-btn" aria-label="Settings">‚öô Settings</button>
                    <div class="settings-dropdown" id="settings-dropdown">
                        <div class="dropdown-item" id="theme-dark-btn">
                            <span>üåô</span>
                            <span>Dark Theme</span>
                        </div>
                        <div class="dropdown-item" id="theme-light-btn">
                            <span>‚òÄÔ∏è</span>
                            <span>Light Theme</span>
                        </div>
                        <div class="dropdown-item" id="theme-blue-btn">
                            <span>üîµ</span>
                            <span>Blue Theme</span>
                        </div>
                        <div class="dropdown-item" id="theme-green-btn">
                            <span>üü¢</span>
                            <span>Green Theme</span>
                        </div>
                        <div class="dropdown-item" id="theme-purple-btn">
                            <span>üü£</span>
                            <span>Purple Theme</span>
                        </div>
                        <div class="dropdown-item" id="share-btn">
                            <span>üì§</span>
                            <span>Share</span>
                        </div>
                        <div class="dropdown-item" id="focus-mode-btn">
                            <span>üéØ</span>
                            <span>Focus Mode</span>
                        </div>
                        <div class="dropdown-item" id="distraction-block-btn">
                            <span>üö´</span>
                            <span>Block Distractions</span>
                        </div>
                        <div class="dropdown-item" id="gesture-config-btn">
                            <span>üëÜ</span>
                            <span>Touch Gestures</span>
                        </div>
                        <div class="dropdown-item" id="keyboard-help-btn">
                            <span>‚å®Ô∏è</span>
                            <span>Keyboard Shortcuts</span>
                        </div>
                        <div class="dropdown-item" id="close-dropdown-btn">
                            <span>‚úñÔ∏è</span>
                            <span>Close</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- PDF Container -->
        <div class="pdf-container" id="pdf-container">
            <div class="loading" id="loading">Loading PDF...</div>
            <div class="canvas-container" id="canvas-container" style="display: none;">
                <canvas id="pdf-canvas"></canvas>
            </div>
        </div>

        <!-- Bottom Toolbar -->
        <div class="bottom-toolbar" id="bottom-toolbar">
            <div class="toolbar-left">
                <div class="toolbar-section">
                    <button class="btn btn-ghost" id="prev-btn" aria-label="Previous page">‚Üê</button>
                    <div class="page-info">
                        <span>Page</span>
                        <input type="number" class="page-input" id="page-input" min="1" aria-label="Current page">
                        <span>of</span>
                        <span id="total-pages">0</span>
                    </div>
                    <button class="btn btn-ghost" id="next-btn" aria-label="Next page">‚Üí</button>
                </div>
            </div>
            
            <div class="toolbar-center">
                <div class="toolbar-section">
                    <div class="zoom-controls">
                        <button class="btn btn-secondary" id="zoom-out-btn" aria-label="Zoom out">‚àí</button>
                        <div class="zoom-display" id="zoom-display">100%</div>
                        <button class="btn btn-secondary" id="zoom-in-btn" aria-label="Zoom in">+</button>
                    </div>
                    <button class="btn btn-secondary" id="fullscreen-btn" aria-label="Toggle fullscreen">‚õ∂</button>
                </div>
            </div>
            
            <div class="toolbar-right">
                <div class="reading-progress" id="reading-progress">
                    <div class="progress-info">
                        <span class="progress-percentage" id="progress-percentage">0%</span>
                        <span class="time-estimate" id="time-estimate">-- min left</span>
                    </div>
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="progress-bar"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Exit Modal -->
    <div class="modal" id="exit-modal">
        <div class="modal-content">
            <h3>Exit Reader?</h3>
            <div class="modal-buttons">
                <button class="btn" id="continue-reading-btn">Continue Reading</button>
                <button class="btn" id="exit-anyway-btn">Exit</button>
            </div>
        </div>
    </div>

    <!-- Break Ad -->
    <div class="break-ad" id="break-ad">
        <div class="break-ad-content">
            <div id="break-ad-html">
                <!-- Ad content will be inserted here -->
                <h3>Advertisement</h3>
                <p>This is a sample ad. Replace with your ad content.</p>
            </div>
            <button class="btn" id="continue-btn" style="margin-top: 20px;">Continue Reading</button>
        </div>
    </div>
    <script>
        // ===== CONFIGURATION - REPLACE THESE VALUES =====
        // Replace with your actual PDF URL
        const PDF_URL = 'https://raw.githubusercontent.com/ai-modren-tools/pdf-novel/main/%D9%82%D8%B1%D8%B6%D9%90%20%D9%85%D8%AD%D8%A8%D8%AA.pdf';
        
        // Mediafire functionality removed as requested
        
        // Book configuration
        const BOOK_CONFIG = {
            id: 'default-book', // Used for localStorage key
            title: 'Jarvis Project Starter Documentation',
            breakAd: {
                enabled: true,
                interval: 10, // Show ad every 10 pages
                html: '<h3>Sample Advertisement</h3><p>Your ad content goes here!</p><img src="https://via.placeholder.com/300x200" alt="Ad">'
            }
        };
        
        // Analytics callback - customize as needed
        function analyticsCallback(event, payload) {
            console.log('Analytics Event:', event, payload);
            // Replace with your analytics implementation
            // Examples: Google Analytics, Facebook Pixel, etc.
        }
        
        // ===== PDF READER IMPLEMENTATION =====
        class PDFReader {
            constructor() {
                this.pdf = null;
                this.currentPage = 1;
                this.totalPages = 0;
                this.scale = 1.0;
                this.canvas = document.getElementById('pdf-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvasContainer = document.getElementById('canvas-container');
                this.isFullscreen = false;
                this.pagesViewed = new Set();
                this.lastBreakAdPage = 0;
                this.readingStartTime = new Date();
                this.averageReadingSpeed = 2; // minutes per page (default)
                this.focusMode = localStorage.getItem('pdf-reader-focus-mode') === 'true' || false;
                this.distractionBlocking = localStorage.getItem('pdf-reader-distraction-block') === 'true' || false;
                this.originalTitle = document.title;
                this.isTabActive = true;
                
                // Gesture configuration
                this.gestureConfig = JSON.parse(localStorage.getItem('pdf-reader-gestures')) || {
                    doubleTapZoom: true,
                    pinchZoom: true,
                    doubleTapZoomLevel: 2.0,
                    smoothZoom: true
                };
                
                // Double tap detection
                this.lastTapTime = 0;
                this.tapTimeout = null;
                
                // Auto-hide toolbar functionality
                this.toolbarsVisible = true;
                this.hideTimeout = null;
                this.lastActivity = Date.now();
                
                this.initializeElements();
                this.bindEvents();
                this.loadBookmark();
                this.loadPDF();
                this.setupViewportListeners();
                
                // Fire analytics event
                analyticsCallback('reader_open', {
                    bookId: BOOK_CONFIG.id,
                    timestamp: new Date().toISOString()
                });
            }

            // Utility: debounce
            debounce(fn, wait = 150) {
                let t;
                return (...args) => {
                    clearTimeout(t);
                    t = setTimeout(() => fn.apply(this, args), wait);
                };
            }

            // Listen for viewport-affecting events and keep the canvas fit responsive
            setupViewportListeners() {
                this.onViewportChangeDebounced = this.debounce(() => this.onViewportChange(), 150);
                try {
                    window.addEventListener('resize', this.onViewportChangeDebounced, { passive: true });
                    window.addEventListener('orientationchange', this.onViewportChangeDebounced, { passive: true });
                    if (window.matchMedia) {
                        const mq = window.matchMedia('(orientation: landscape)');
                        if (mq && mq.addEventListener) {
                            mq.addEventListener('change', this.onViewportChangeDebounced);
                        }
                    }
                    document.addEventListener('fullscreenchange', this.onViewportChangeDebounced, { passive: true });
                    // iOS Safari visual viewport changes
                    if (window.visualViewport) {
                        window.visualViewport.addEventListener('resize', this.onViewportChangeDebounced, { passive: true });
                    }
                } catch (e) {
                    // Fail-safe: still try to respond on resize only
                    window.addEventListener('resize', this.onViewportChangeDebounced);
                }
            }

            onViewportChange() {
                if (!this.pdf) return;
                // Recompute a fit-to-view scale so content remains visible
                this.smoothZoomToFit();
            }
            
            // Decide when to prefer fit-width (small screens)
            isSmallScreen() {
                if (window.matchMedia) {
                    return window.matchMedia('(max-width: 768px)').matches;
                }
                return window.innerWidth <= 768;
            }

            // Compute inner size of canvas container (subtract paddings)
            getContainerInnerSize() {
                const container = this.elements.canvasContainer;
                const styles = window.getComputedStyle(container);
                const paddingX = parseFloat(styles.paddingLeft || '0') + parseFloat(styles.paddingRight || '0');
                const paddingY = parseFloat(styles.paddingTop || '0') + parseFloat(styles.paddingBottom || '0');
                return {
                    width: container.clientWidth - paddingX,
                    height: container.clientHeight - paddingY
                };
            }
            
            initializeElements() {
                this.elements = {
                    loading: document.getElementById('loading'),
                    canvas: document.getElementById('pdf-canvas'),
                    bookTitle: document.getElementById('book-title'),
                    pageInput: document.getElementById('page-input'),
                    totalPages: document.getElementById('total-pages'),
                    zoomDisplay: document.getElementById('zoom-display'),
                    prevBtn: document.getElementById('prev-btn'),
                    nextBtn: document.getElementById('next-btn'),
                    zoomInBtn: document.getElementById('zoom-in-btn'),
                    zoomOutBtn: document.getElementById('zoom-out-btn'),
                    fullscreenBtn: document.getElementById('fullscreen-btn'),
                    backBtn: document.getElementById('back-btn'),
                    settingsBtn: document.getElementById('settings-btn'),
                    settingsDropdown: document.getElementById('settings-dropdown'),
                    exitModal: document.getElementById('exit-modal'),
                    breakAd: document.getElementById('break-ad'),
                    breakAdHtml: document.getElementById('break-ad-html'),
                    progressPercentage: document.getElementById('progress-percentage'),
                    timeEstimate: document.getElementById('time-estimate'),
                    progressBar: document.getElementById('progress-bar'),
                    bottomToolbar: document.getElementById('bottom-toolbar'),
                    readingProgress: document.getElementById('reading-progress'),
                    canvasContainer: document.getElementById('canvas-container')
                };
                
                this.currentTheme = localStorage.getItem('pdf-reader-theme') || 'dark';
                this.applyTheme(this.currentTheme);
                this.applyFocusMode(this.focusMode);
                this.applyDistractionBlocking(this.distractionBlocking);
                
                this.elements.bookTitle.textContent = BOOK_CONFIG.title;
            }
            
            bindEvents() {
                // Navigation events
                this.elements.prevBtn.addEventListener('click', () => this.previousPage());
                this.elements.nextBtn.addEventListener('click', () => this.nextPage());
                this.elements.pageInput.addEventListener('change', (e) => this.goToPage(parseInt(e.target.value)));
                
                // Zoom events
                this.elements.zoomInBtn.addEventListener('click', () => this.zoomIn());
                this.elements.zoomOutBtn.addEventListener('click', () => this.zoomOut());
                
                // Fullscreen event
                this.elements.fullscreenBtn.addEventListener('click', () => this.toggleFullscreen());
                
                // Back button - try browser back first, then show exit modal
                this.elements.backBtn.addEventListener('click', () => this.handleBackButton());
                
                // Settings button and dropdown
                this.elements.settingsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.toggleSettingsDropdown();
                });
                
                // Settings dropdown items - Theme selection
                document.getElementById('theme-dark-btn').addEventListener('click', () => this.setTheme('dark'));
                document.getElementById('theme-light-btn').addEventListener('click', () => this.setTheme('light'));
                document.getElementById('theme-blue-btn').addEventListener('click', () => this.setTheme('blue'));
                document.getElementById('theme-green-btn').addEventListener('click', () => this.setTheme('green'));
                document.getElementById('theme-purple-btn').addEventListener('click', () => this.setTheme('purple'));
                document.getElementById('share-btn').addEventListener('click', () => this.shareReader());
                document.getElementById('focus-mode-btn').addEventListener('click', () => this.toggleFocusMode());
                document.getElementById('distraction-block-btn').addEventListener('click', () => this.toggleDistractionBlocking());
                document.getElementById('gesture-config-btn').addEventListener('click', () => this.showGestureConfig());
                document.getElementById('keyboard-help-btn').addEventListener('click', () => this.showKeyboardHelp());
                document.getElementById('close-dropdown-btn').addEventListener('click', () => this.hideSettingsDropdown());
                
                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.settings-container')) {
                        this.hideSettingsDropdown();
                    }
                });
                
                // Exit modal events
                document.getElementById('continue-reading-btn').addEventListener('click', () => this.hideExitModal());
                document.getElementById('exit-anyway-btn').addEventListener('click', () => this.exitAnyway());
                
                // Break ad continue button
                document.getElementById('continue-btn').addEventListener('click', () => this.hideBreakAd());
                
                // Keyboard navigation
                document.addEventListener('keydown', (e) => this.handleKeyboard(e));
                
                // Page visibility API for tab switching detection
                document.addEventListener('visibilitychange', () => this.handleVisibilityChange());
                
                // Touch events for mobile zoom
                this.setupTouchEvents();
                
                // Auto-hide toolbar setup
                this.setupAutoHideToolbars();
                
                // Prevent context menu on canvas
                this.elements.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }
            
            async loadPDF() {
                try {
                    // Update loading message
                    this.elements.loading.innerHTML = 'Loading PDF...<div class="loading-progress"></div>';
                    
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                    
                    // Add loading progress tracking
                    const loadingTask = pdfjsLib.getDocument({
                        url: PDF_URL,
                        onProgress: (progress) => {
                            if (progress.total > 0) {
                                const percent = Math.round((progress.loaded / progress.total) * 100);
                                this.elements.loading.innerHTML = `Loading PDF... ${percent}%<div class="loading-progress"></div>`;
                            }
                        }
                    });
                    
                    this.pdf = await loadingTask.promise;
                    this.totalPages = this.pdf.numPages;
                    
                    this.elements.totalPages.textContent = this.totalPages;
                    this.elements.pageInput.max = this.totalPages;
                    
                    this.elements.loading.style.display = 'none';
                    this.elements.canvasContainer.style.display = 'flex';
                    
                    await this.renderPage();
                    
                    // Ensure mobile starts in fit-width mode even if a bookmark stored a different zoom
                    if (this.isSmallScreen()) {
                        this.smoothZoomToFit();
                    }
                    
                    // Show success notification
                    this.showNotification(`PDF loaded successfully! ${this.totalPages} pages`, 'success');
                    
                    analyticsCallback('pdf_loaded_successfully', {
                        bookId: BOOK_CONFIG.id,
                        totalPages: this.totalPages,
                        timestamp: new Date().toISOString()
                    });
                    
                } catch (error) {
                    console.error('Error loading PDF:', error);
                    this.showError('Failed to load PDF', this.getErrorMessage(error));
                    
                    analyticsCallback('pdf_load_error', {
                        bookId: BOOK_CONFIG.id,
                        error: error.message,
                        timestamp: new Date().toISOString()
                    });
                }
            }
            
            getErrorMessage(error) {
                if (error.name === 'MissingPDFException') {
                    return 'The PDF file could not be found. Please check the URL.';
                } else if (error.name === 'InvalidPDFException') {
                    return 'The file is not a valid PDF document.';
                } else if (error.name === 'UnexpectedResponseException') {
                    return 'Network error. Please check your internet connection.';
                } else if (error.name === 'PasswordException') {
                    return 'This PDF is password protected.';
                } else {
                    return 'An unexpected error occurred while loading the PDF.';
                }
            }
            
            showError(title, message) {
                this.elements.loading.innerHTML = `
                    <div class="error-state">
                        <div class="error-icon">‚ö†Ô∏è</div>
                        <div class="error-message">${title}</div>
                        <div class="error-details">${message}</div>
                        <button class="btn" onclick="location.reload()">Retry</button>
                    </div>
                `;
            }
            
            async renderPage() {
                if (!this.pdf) return;
                
                try {
                    const page = await this.pdf.getPage(this.currentPage);
                    
                    // Get the base viewport at scale 1.0 to determine original size
                    const baseViewport = page.getViewport({ scale: 1.0 });
                    
                    // Calculate the actual scale based on container size for initial fit
                    const { width: containerWidth, height: containerHeight } = this.getContainerInnerSize();
                    
                    // If this is the first render or scale is 1.0, fit to container
                    if (this.scale === 1.0) {
                        const scaleX = containerWidth / baseViewport.width;
                        const scaleY = containerHeight / baseViewport.height;
                        const preferWidth = this.isSmallScreen();
                        this.scale = preferWidth ? scaleX : Math.min(scaleX, scaleY, 1.0); // Mobile prefers fit-width
                    }
                    
                    // Apply the current scale
                    const viewport = page.getViewport({ scale: this.scale });
                    
                    // Set canvas dimensions
                    this.canvas.width = viewport.width;
                    this.canvas.height = viewport.height;
                    
                    // Set CSS size to match canvas size (important for zoom)
                    this.canvas.style.width = viewport.width + 'px';
                    this.canvas.style.height = viewport.height + 'px';
                    
                    const renderContext = {
                        canvasContext: this.ctx,
                        viewport: viewport
                    };
                    
                    await page.render(renderContext).promise;
                    
                    // Update UI
                    this.elements.pageInput.value = this.currentPage;
                    this.elements.zoomDisplay.textContent = Math.round(this.scale * 100) + '%';
                    
                    // Update navigation buttons
                    this.elements.prevBtn.disabled = this.currentPage <= 1;
                    this.elements.nextBtn.disabled = this.currentPage >= this.totalPages;
                    
                    // Save bookmark
                    this.saveBookmark();
                    
                    // Update reading progress
                    this.updateReadingProgress();
                    
                    // Update tab title if distraction blocking is enabled
                    if (this.distractionBlocking) {
                        this.updateTabTitle();
                    }
                    
                    // Track page view
                    if (!this.pagesViewed.has(this.currentPage)) {
                        this.pagesViewed.add(this.currentPage);
                        analyticsCallback('page_view', {
                            bookId: BOOK_CONFIG.id,
                            page: this.currentPage,
                            totalPages: this.totalPages,
                            timestamp: new Date().toISOString()
                        });
                    }
                    
                    // Check for break ad
                    this.checkBreakAd();
                    
                } catch (error) {
                    console.error('Error rendering page:', error);
                }
            }
            
            // Navigation methods
            async previousPage() {
                if (this.currentPage > 1) {
                    this.currentPage--;
                    await this.renderPage();
                }
            }
            
            async nextPage() {
                if (this.currentPage < this.totalPages) {
                    this.currentPage++;
                    await this.renderPage();
                }
            }
            
            async goToPage(pageNum) {
                if (pageNum >= 1 && pageNum <= this.totalPages) {
                    this.currentPage = pageNum;
                    await this.renderPage();
                }
            }
            
            // Touch events setup for mobile
            setupTouchEvents() {
                let initialDistance = 0;
                let initialScale = 1;
                let isPinching = false;
                
                // Swipe gesture variables
                let startX = 0;
                let startY = 0;
                let startTime = 0;
                
                // Touch start handler
                this.elements.canvas.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    startX = touch.clientX;
                    startY = touch.clientY;
                    startTime = Date.now();
                    
                    // Double tap zoom
                    if (e.touches.length === 1 && this.gestureConfig.doubleTapZoom) {
                        const currentTime = new Date().getTime();
                        const tapLength = currentTime - this.lastTapTime;
                        
                        if (tapLength < 500 && tapLength > 0) {
                            e.preventDefault();
                            this.handleDoubleTap(e.touches[0]);
                        }
                        this.lastTapTime = currentTime;
                    }
                    
                    // Pinch zoom setup
                    if (e.touches.length === 2 && this.gestureConfig.pinchZoom) {
                        e.preventDefault();
                        isPinching = true;
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        initialDistance = Math.sqrt(
                            Math.pow(touch2.clientX - touch1.clientX, 2) +
                            Math.pow(touch2.clientY - touch1.clientY, 2)
                        );
                        initialScale = this.scale;
                        
                        // Add zooming class for faster transitions during pinch
                        this.elements.canvas.classList.add('zooming');
                    }
                });
                
                this.elements.canvas.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 2 && isPinching && this.gestureConfig.pinchZoom) {
                        e.preventDefault();
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        const currentDistance = Math.sqrt(
                            Math.pow(touch2.clientX - touch1.clientX, 2) +
                            Math.pow(touch2.clientY - touch1.clientY, 2)
                        );
                        
                        if (initialDistance > 0) {
                            const scaleChange = currentDistance / initialDistance;
                            this.scale = Math.min(Math.max(initialScale * scaleChange, 0.2), 5.0);
                            this.renderPage();
                        }
                    }
                });
                
                this.elements.canvas.addEventListener('touchend', (e) => {
                    if (e.touches.length < 2) {
                        isPinching = false;
                        initialDistance = 0;
                        // Remove zooming class to restore smooth transitions
                        this.elements.canvas.classList.remove('zooming');
                    }
                    
                    // Handle swipe gestures
                    if (e.changedTouches.length === 1 && !isPinching) {
                        const touch = e.changedTouches[0];
                        const endX = touch.clientX;
                        const endY = touch.clientY;
                        const endTime = Date.now();
                        
                        const deltaX = endX - startX;
                        const deltaY = endY - startY;
                        const deltaTime = endTime - startTime;
                        
                        // Check if it's a swipe (fast movement, primarily horizontal)
                        if (deltaTime < 300 && Math.abs(deltaX) > 50 && Math.abs(deltaX) > Math.abs(deltaY) * 2) {
                            if (deltaX > 0) {
                                // Swipe right - previous page
                                this.previousPage();
                            } else {
                                // Swipe left - next page
                                this.nextPage();
                            }
                            
                            analyticsCallback('swipe_navigation', {
                                bookId: BOOK_CONFIG.id,
                                direction: deltaX > 0 ? 'right' : 'left',
                                page: this.currentPage,
                                timestamp: new Date().toISOString()
                            });
                        }
                    }
                });
            }
            
            // Double tap zoom handler
            handleDoubleTap(touch) {
                const rect = this.elements.canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                
                // Calculate zoom center point
                const centerX = x / rect.width;
                const centerY = y / rect.height;
                
                // Toggle between fit-to-screen and zoom level
                if (this.scale < this.gestureConfig.doubleTapZoomLevel) {
                    this.smoothZoomTo(this.gestureConfig.doubleTapZoomLevel, centerX, centerY);
                } else {
                    this.smoothZoomToFit();
                }
                
                analyticsCallback('double_tap_zoom', {
                    bookId: BOOK_CONFIG.id,
                    page: this.currentPage,
                    newScale: this.scale,
                    timestamp: new Date().toISOString()
                });
            }
            
            // Smooth zoom methods
            smoothZoomTo(targetScale, centerX = 0.5, centerY = 0.5) {
                if (!this.gestureConfig.smoothZoom) {
                    this.scale = Math.min(Math.max(targetScale, 0.2), 5.0);
                    this.renderPage();
                    return;
                }
                
                const startScale = this.scale;
                const endScale = Math.min(Math.max(targetScale, 0.2), 5.0);
                const duration = 300; // milliseconds
                const startTime = performance.now();
                
                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Easing function (ease-out)
                    const easeOut = 1 - Math.pow(1 - progress, 3);
                    
                    this.scale = startScale + (endScale - startScale) * easeOut;
                    this.renderPage();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                };
                
                requestAnimationFrame(animate);
            }
            
            smoothZoomToFit() {
                if (!this.pdf) return;
                
                this.pdf.getPage(this.currentPage).then(page => {
                    const baseViewport = page.getViewport({ scale: 1.0 });
                    const { width: containerWidth, height: containerHeight } = this.getContainerInnerSize();
                    
                    const scaleX = containerWidth / baseViewport.width;
                    const scaleY = containerHeight / baseViewport.height;
                    const preferWidth = this.isSmallScreen();
                    const fitScale = preferWidth ? scaleX : Math.min(scaleX, scaleY, 1.0);
                    
                    this.smoothZoomTo(fitScale);
                });
            }
            
            // Zoom methods
            async zoomIn() {
                if (this.gestureConfig.smoothZoom) {
                    this.smoothZoomTo(this.scale * 1.25);
                } else {
                    this.scale = Math.min(this.scale * 1.25, 5.0);
                    await this.renderPage();
                }
            }
            
            async zoomOut() {
                if (this.gestureConfig.smoothZoom) {
                    this.smoothZoomTo(this.scale / 1.25);
                } else {
                    this.scale = Math.max(this.scale / 1.25, 0.2);
                    await this.renderPage();
                }
            }
            
            // Fullscreen toggle
            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                    this.isFullscreen = true;
                    this.elements.fullscreenBtn.textContent = '‚õ∂ Exit';
                } else {
                    document.exitFullscreen();
                    this.isFullscreen = false;
                    this.elements.fullscreenBtn.textContent = '‚õ∂';
                }
                // Recalculate fit after the fullscreen state changes
                if (this.onViewportChangeDebounced) {
                    this.onViewportChangeDebounced();
                } else {
                    this.smoothZoomToFit();
                }
            }
            
            // Reading Progress functionality
            updateReadingProgress() {
                if (this.totalPages === 0) return;
                
                // Calculate progress percentage
                const progressPercentage = Math.round((this.currentPage / this.totalPages) * 100);
                this.elements.progressPercentage.textContent = `${progressPercentage}%`;
                
                // Update progress bar
                this.elements.progressBar.style.width = `${progressPercentage}%`;
                
                // Calculate time estimate
                const pagesRemaining = this.totalPages - this.currentPage;
                const timeEstimate = this.calculateTimeEstimate(pagesRemaining);
                this.elements.timeEstimate.textContent = timeEstimate;
                
                // Update reading speed based on actual reading time
                this.updateReadingSpeed();
            }
            
            calculateTimeEstimate(pagesRemaining) {
                if (pagesRemaining <= 0) {
                    return 'Complete!';
                }
                
                const estimatedMinutes = Math.ceil(pagesRemaining * this.averageReadingSpeed);
                
                if (estimatedMinutes < 60) {
                    return `${estimatedMinutes} min left`;
                } else {
                    const hours = Math.floor(estimatedMinutes / 60);
                    const minutes = estimatedMinutes % 60;
                    if (minutes === 0) {
                        return `${hours}h left`;
                    } else {
                        return `${hours}h ${minutes}m left`;
                    }
                }
            }
            
            updateReadingSpeed() {
                // Calculate actual reading speed based on pages read and time elapsed
                const currentTime = new Date();
                const timeElapsed = (currentTime - this.readingStartTime) / (1000 * 60); // minutes
                const pagesRead = this.pagesViewed.size;
                
                if (pagesRead > 2 && timeElapsed > 2) { // Only update after reading a few pages
                    const actualSpeed = timeElapsed / pagesRead;
                    // Use a weighted average to smooth out the reading speed
                    this.averageReadingSpeed = (this.averageReadingSpeed * 0.7) + (actualSpeed * 0.3);
                    
                    // Clamp reading speed to reasonable bounds (0.5 to 10 minutes per page)
                    this.averageReadingSpeed = Math.max(0.5, Math.min(10, this.averageReadingSpeed));
                }
            }

            // Bookmark functionality
            saveBookmark() {
                const bookmark = {
                    page: this.currentPage,
                    zoom: this.scale,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem(`bookmark_${BOOK_CONFIG.id}`, JSON.stringify(bookmark));
            }
            
            loadBookmark() {
                const bookmark = localStorage.getItem(`bookmark_${BOOK_CONFIG.id}`);
                if (bookmark) {
                    try {
                        const data = JSON.parse(bookmark);
                        this.currentPage = data.page || 1;
                        this.scale = data.zoom || 1.0;
                    } catch (error) {
                        console.error('Error loading bookmark:', error);
                    }
                }
            }
            
            // Back button functionality
            handleBackButton() {
                if (window.history.length > 1) {
                    window.history.back();
                } else {
                    this.showExitModal();
                }

                // Track analytics
                analyticsCallback('back_button_clicked', {
                    bookId: BOOK_CONFIG.id,
                    currentPage: this.currentPage,
                    timestamp: new Date().toISOString()
                });
            }
            
            // Break Ad functionality
            checkBreakAd() {
                if (!BOOK_CONFIG.breakAd.enabled) return;
                
                const pagesSinceLastAd = this.currentPage - this.lastBreakAdPage;
                if (pagesSinceLastAd >= BOOK_CONFIG.breakAd.interval && this.currentPage > 1) {
                    this.showBreakAd();
                }
            }
            
            showBreakAd() {
                this.elements.breakAdHtml.innerHTML = BOOK_CONFIG.breakAd.html;
                this.elements.breakAd.style.display = 'block';
                this.lastBreakAdPage = this.currentPage;
                
                analyticsCallback('break_ad_shown', {
                    bookId: BOOK_CONFIG.id,
                    page: this.currentPage,
                    timestamp: new Date().toISOString()
                });
            }
            
            hideBreakAd() {
                this.elements.breakAd.style.display = 'none';
            }
            
            // Enhanced back button handler
            handleBackButton() {
                // Check if any modals or dropdowns are open first
                if (this.elements.exitModal.style.display === 'block') {
                    this.hideExitModal();
                    return;
                }
                
                if (this.elements.settingsDropdown.classList.contains('show')) {
                    this.hideSettingsDropdown();
                    return;
                }
                
                // If in fullscreen, exit fullscreen first
                if (this.isFullscreen) {
                    this.toggleFullscreen();
                    this.showNotification('Exited fullscreen', 'info', 2000);
                    return;
                }
                
                // Check if user has made significant progress (more than 5 pages)
                const hasProgress = this.currentPage > 5;
                
                // Check browser history with more sophisticated detection
                const hasHistory = this.checkBrowserHistory();
                
                if (hasHistory) {
                    // Add confirmation if user has made progress
                    if (hasProgress) {
                        this.showBackConfirmation();
                    } else {
                        this.navigateBack();
                    }
                } else {
                    // No browser history, show exit modal
                    this.showExitModal();
                }
                
                analyticsCallback('back_button_clicked', {
                    bookId: BOOK_CONFIG.id,
                    page: this.currentPage,
                    hasProgress: hasProgress,
                    hasHistory: hasHistory,
                    timestamp: new Date().toISOString()
                });
            }
            
            // Check if browser has navigable history
            checkBrowserHistory() {
                // Multiple methods to detect if we can go back
                try {
                    // Method 1: Check history length (not always reliable)
                    if (window.history.length <= 1) {
                        return false;
                    }
                    
                    // Method 2: Check if we were referred from another page
                    if (document.referrer && document.referrer !== window.location.href) {
                        return true;
                    }
                    
                    // Method 3: Check if we have navigation entries (modern browsers)
                    if ('navigation' in window && window.navigation.entries) {
                        return window.navigation.entries().length > 1;
                    }
                    
                    // Method 4: Check performance navigation API
                    if (window.performance && window.performance.navigation) {
                        const navType = window.performance.navigation.type;
                        // TYPE_NAVIGATE = 0, TYPE_RELOAD = 1, TYPE_BACK_FORWARD = 2
                        return navType !== 0; // Not a direct navigation
                    }
                    
                    // Default to true if history length > 1
                    return window.history.length > 1;
                } catch (error) {
                    console.warn('Error checking browser history:', error);
                    return window.history.length > 1;
                }
            }
            
            // Show confirmation before navigating back with progress
            showBackConfirmation() {
                const confirmHtml = `
                    <div class="modal-content">
                        <h3>‚¨ÖÔ∏è Go Back?</h3>
                        <p style="margin: 20px 0; text-align: center; color: var(--text-secondary);">
                            You're on page ${this.currentPage} of ${this.totalPages}.<br>
                            Your reading progress will be saved.
                        </p>
                        <div class="modal-buttons">
                            <button class="btn btn-secondary" onclick="reader.hideExitModal()">Stay Here</button>
                            <button class="btn btn-primary" onclick="reader.confirmNavigateBack()">Go Back</button>
                        </div>
                    </div>
                `;
                
                this.elements.exitModal.innerHTML = confirmHtml;
                this.elements.exitModal.style.display = 'block';
            }
            
            // Confirm and execute back navigation
            confirmNavigateBack() {
                this.hideExitModal();
                this.navigateBack();
            }
            
            // Execute the actual back navigation
            navigateBack() {
                // Add loading state to back button
                this.elements.backBtn.classList.add('loading');
                this.elements.backBtn.disabled = true;
                
                // Save current progress before leaving
                this.saveBookmark();
                
                // Show leaving notification
                this.showNotification('Navigating back...', 'info', 1500);
                
                // Small delay to show notification
                setTimeout(() => {
                    try {
                        window.history.back();
                        
                        // Remove loading state after a delay (in case navigation fails)
                        setTimeout(() => {
                            this.elements.backBtn.classList.remove('loading');
                            this.elements.backBtn.disabled = false;
                        }, 2000);
                        
                    } catch (error) {
                        console.error('Navigation back failed:', error);
                        // Remove loading state
                        this.elements.backBtn.classList.remove('loading');
                        this.elements.backBtn.disabled = false;
                        // Fallback: try to close window or show exit modal
                        this.handleNavigationFallback();
                    }
                }, 500);
                
                analyticsCallback('navigation_back_executed', {
                    bookId: BOOK_CONFIG.id,
                    page: this.currentPage,
                    timestamp: new Date().toISOString()
                });
            }
            
            // Handle cases where back navigation fails
            handleNavigationFallback() {
                // Try to close the window (works if opened by script)
                try {
                    window.close();
                } catch (error) {
                    console.warn('Cannot close window:', error);
                }
                
                // If window.close() doesn't work, show exit modal
                setTimeout(() => {
                    if (!window.closed) {
                        this.showExitModal();
                        this.showNotification('Cannot navigate back. Use the exit options below.', 'info', 4000);
                    }
                }, 1000);
            }
            
            // Enhanced exit modal with better options
            showExitModal() {
                const hasProgress = this.currentPage > 1;
                const progressText = hasProgress ? 
                    `You're on page ${this.currentPage} of ${this.totalPages}. Your progress will be saved.` :
                    'You haven\'t started reading yet.';
                
                const exitHtml = `
                    <div class="modal-content">
                        <h3>üìñ Exit PDF Reader?</h3>
                        <p style="margin: 20px 0; text-align: center; color: var(--text-secondary);">
                            ${progressText}
                        </p>
                        <div class="modal-buttons">
                            <button class="btn btn-secondary" onclick="reader.hideExitModal()">Continue Reading</button>
                            <button class="btn btn-primary" onclick="reader.exitReader()">Exit Reader</button>
                        </div>
                        ${hasProgress ? '<p style="font-size: 12px; color: var(--text-tertiary); text-align: center; margin-top: 15px;">üíæ Bookmark saved automatically</p>' : ''}
                    </div>
                `;
                
                this.elements.exitModal.innerHTML = exitHtml;
                this.elements.exitModal.style.display = 'block';
            }
            
            // Exit the reader with proper cleanup
            exitReader() {
                // Save final bookmark
                this.saveBookmark();
                
                // Show goodbye message
                this.showNotification('Thanks for reading! üìö', 'success', 2000);
                
                // Analytics
                analyticsCallback('reader_exit', {
                    bookId: BOOK_CONFIG.id,
                    finalPage: this.currentPage,
                    totalPages: this.totalPages,
                    readingProgress: Math.round((this.currentPage / this.totalPages) * 100),
                    timestamp: new Date().toISOString()
                });
                
                // Try multiple exit strategies
                setTimeout(() => {
                    // Strategy 1: Close window (if opened by script)
                    try {
                        window.close();
                    } catch (error) {
                        console.warn('Cannot close window:', error);
                    }
                    
                    // Strategy 2: Navigate to a blank page
                    setTimeout(() => {
                        if (!window.closed) {
                            try {
                                window.location.href = 'about:blank';
                            } catch (error) {
                                // Strategy 3: Navigate to previous page or home
                                try {
                                    if (document.referrer) {
                                        window.location.href = document.referrer;
                                    } else {
                                        window.location.href = '/';
                                    }
                                } catch (finalError) {
                                    // Strategy 4: Show final message
                                    document.body.innerHTML = `
                                        <div style="display: flex; align-items: center; justify-content: center; height: 100vh; flex-direction: column; font-family: system-ui;">
                                            <h2>üìö Thanks for reading!</h2>
                                            <p>You can safely close this tab now.</p>
                                            <button onclick="window.close()" style="margin-top: 20px; padding: 10px 20px; font-size: 16px;">Close Tab</button>
                                        </div>
                                    `;
                                }
                            }
                        }
                    }, 1000);
                }, 1500);
            }
            
            hideExitModal() {
                this.elements.exitModal.style.display = 'none';
            }
            
            // Settings dropdown functionality
            toggleSettingsDropdown() {
                const dropdown = this.elements.settingsDropdown;
                dropdown.classList.toggle('show');
                this.updateThemeButtons();
            }
            
            hideSettingsDropdown() {
                this.elements.settingsDropdown.classList.remove('show');
            }
            
            // Theme switching functionality
            setTheme(theme) {
                this.currentTheme = theme;
                this.applyTheme(theme);
                localStorage.setItem('pdf-reader-theme', theme);
                this.hideSettingsDropdown();
                
                analyticsCallback('theme_changed', {
                    bookId: BOOK_CONFIG.id,
                    theme: theme,
                    timestamp: new Date().toISOString()
                });
            }
            
            applyTheme(theme) {
                // Remove all theme classes
                document.body.classList.remove('theme-light', 'theme-blue', 'theme-green', 'theme-purple');
                
                // Apply new theme class (dark is default, no class needed)
                if (theme !== 'dark') {
                    document.body.classList.add(`theme-${theme}`);
                }
                
                this.updateThemeButtons();
                this.showNotification(`${theme.charAt(0).toUpperCase() + theme.slice(1)} theme applied`, 'success', 2000);
            }
            
            updateThemeButtons() {
                const themes = ['dark', 'light', 'blue', 'green', 'purple'];
                
                themes.forEach(themeName => {
                    const btn = document.getElementById(`theme-${themeName}-btn`);
                    if (btn) {
                        btn.classList.toggle('active', this.currentTheme === themeName);
                    }
                });
                
                // Update other buttons
                const focusBtn = document.getElementById('focus-mode-btn');
                const distractionBtn = document.getElementById('distraction-block-btn');
                
                if (focusBtn) focusBtn.classList.toggle('active', this.focusMode);
                if (distractionBtn) distractionBtn.classList.toggle('active', this.distractionBlocking);
            }
            
            // Gesture Configuration
            showGestureConfig() {
                const configHtml = `
                    <div class="modal-content">
                        <h3>Touch Gesture Settings</h3>
                        <div style="text-align: left; margin: 20px 0;">
                            <label style="display: block; margin: 10px 0; cursor: pointer;">
                                <input type="checkbox" id="doubleTapZoom" ${this.gestureConfig.doubleTapZoom ? 'checked' : ''} style="margin-right: 8px;">
                                Double-tap to zoom
                            </label>
                            <label style="display: block; margin: 10px 0; cursor: pointer;">
                                <input type="checkbox" id="pinchZoom" ${this.gestureConfig.pinchZoom ? 'checked' : ''} style="margin-right: 8px;">
                                Pinch to zoom
                            </label>
                            <label style="display: block; margin: 10px 0; cursor: pointer;">
                                <input type="checkbox" id="smoothZoom" ${this.gestureConfig.smoothZoom ? 'checked' : ''} style="margin-right: 8px;">
                                Smooth zoom animations
                            </label>
                            <div style="margin: 15px 0;">
                                <label style="display: block; margin-bottom: 5px;">Double-tap zoom level:</label>
                                <input type="range" id="zoomLevel" min="1.5" max="3.0" step="0.1" value="${this.gestureConfig.doubleTapZoomLevel}" style="width: 100%;">
                                <span id="zoomLevelDisplay">${Math.round(this.gestureConfig.doubleTapZoomLevel * 100)}%</span>
                            </div>
                        </div>
                        <div class="modal-buttons">
                            <button class="btn" onclick="reader.saveGestureConfig()">Save</button>
                            <button class="btn" onclick="reader.hideExitModal()">Cancel</button>
                        </div>
                    </div>
                `;
                
                this.elements.exitModal.innerHTML = configHtml;
                this.elements.exitModal.style.display = 'block';
                this.hideSettingsDropdown();
                
                // Add event listener for zoom level slider
                document.getElementById('zoomLevel').addEventListener('input', (e) => {
                    document.getElementById('zoomLevelDisplay').textContent = Math.round(e.target.value * 100) + '%';
                });
            }
            
            saveGestureConfig() {
                this.gestureConfig.doubleTapZoom = document.getElementById('doubleTapZoom').checked;
                this.gestureConfig.pinchZoom = document.getElementById('pinchZoom').checked;
                this.gestureConfig.smoothZoom = document.getElementById('smoothZoom').checked;
                this.gestureConfig.doubleTapZoomLevel = parseFloat(document.getElementById('zoomLevel').value);
                
                localStorage.setItem('pdf-reader-gestures', JSON.stringify(this.gestureConfig));
                this.hideExitModal();
                
                analyticsCallback('gesture_config_saved', {
                    bookId: BOOK_CONFIG.id,
                    config: this.gestureConfig,
                    timestamp: new Date().toISOString()
                });
            }
            
            // Keyboard shortcuts help
            showKeyboardHelp() {
                const helpHtml = `
                    <div class="modal-content">
                        <h3>Keyboard Shortcuts</h3>
                        <div style="text-align: left; margin: 20px 0; display: grid; grid-template-columns: 1fr 2fr; gap: 10px; font-size: 14px;">
                            <strong>Navigation:</strong><span></span>
                            <kbd>‚Üê</kbd><span>Previous page</span>
                            <kbd>‚Üí</kbd><span>Next page</span>
                            <kbd>Space</kbd><span>Next page</span>
                            <kbd>Page Up</kbd><span>Previous page</span>
                            <kbd>Page Down</kbd><span>Next page</span>
                            <kbd>Home</kbd><span>First page</span>
                            <kbd>End</kbd><span>Last page</span>
                            
                            <strong>Zoom:</strong><span></span>
                            <kbd>+</kbd><span>Zoom in</span>
                            <kbd>-</kbd><span>Zoom out</span>
                            <kbd>0</kbd><span>Fit to screen</span>
                            <kbd>1</kbd><span>100% zoom</span>
                            <kbd>2</kbd><span>200% zoom</span>
                            
                            <strong>View:</strong><span></span>
                            <kbd>F</kbd><span>Toggle fullscreen</span>
                            <kbd>F11</kbd><span>Toggle fullscreen</span>
                            <kbd>H</kbd><span>Hide/show toolbars</span>
                            <kbd>Escape</kbd><span>Exit fullscreen or go back</span>
                        </div>
                        <div class="modal-buttons">
                            <button class="btn" onclick="reader.hideExitModal()">Got it!</button>
                        </div>
                    </div>
                `;
                
                this.elements.exitModal.innerHTML = helpHtml;
                this.elements.exitModal.style.display = 'block';
                this.hideSettingsDropdown();
            }
            
            // Auto-hide toolbar functionality
            setupAutoHideToolbars() {
                // Track mouse/touch activity
                const activityEvents = ['mousemove', 'mousedown', 'touchstart', 'touchmove', 'keydown'];
                
                activityEvents.forEach(event => {
                    document.addEventListener(event, () => this.handleUserActivity(), { passive: true });
                });
                
                // Start the auto-hide timer
                this.resetAutoHideTimer();
            }
            
            handleUserActivity() {
                this.lastActivity = Date.now();
                
                // Show toolbars if hidden
                if (!this.toolbarsVisible) {
                    this.showToolbars();
                }
                
                // Reset the hide timer
                this.resetAutoHideTimer();
            }
            
            resetAutoHideTimer() {
                // Clear existing timer
                if (this.hideTimeout) {
                    clearTimeout(this.hideTimeout);
                }
                
                // Set new timer (3 seconds of inactivity)
                this.hideTimeout = setTimeout(() => {
                    if (!this.isFullscreen) return; // Only auto-hide in fullscreen
                    if (this.elements.settingsDropdown.classList.contains('show')) return; // Don't hide if dropdown is open
                    if (this.elements.exitModal.style.display === 'block') return; // Don't hide if modal is open
                    
                    this.hideToolbars();
                }, 3000);
            }
            
            showToolbars() {
                if (this.toolbarsVisible) return;
                
                this.toolbarsVisible = true;
                this.elements.topBar.classList.remove('hidden');
                this.elements.bottomToolbar.classList.remove('hidden');
                
                analyticsCallback('toolbars_shown', {
                    bookId: BOOK_CONFIG.id,
                    timestamp: new Date().toISOString()
                });
            }
            
            hideToolbars() {
                if (!this.toolbarsVisible) return;
                
                this.toolbarsVisible = false;
                this.elements.topBar.classList.add('hidden');
                this.elements.bottomToolbar.classList.add('hidden');
                
                analyticsCallback('toolbars_hidden', {
                    bookId: BOOK_CONFIG.id,
                    timestamp: new Date().toISOString()
                });
            }
            
            toggleToolbars() {
                if (this.toolbarsVisible) {
                    this.hideToolbars();
                } else {
                    this.showToolbars();
                }
                
                // Reset auto-hide timer
            this.resetAutoHideTimer();
        }
        
        // Notification system
        showNotification(message, type = 'info', duration = 3000) {
            // Remove existing notifications
            const existingNotifications = document.querySelectorAll('.notification');
            existingNotifications.forEach(n => n.remove());
            
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            // Add to DOM
            document.body.appendChild(notification);
            
            // Show with animation
            setTimeout(() => notification.classList.add('show'), 100);
            
            // Auto-hide
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, duration);
        }
            
            // Focus Mode functionality
            toggleFocusMode() {
                this.focusMode = !this.focusMode;
                this.applyFocusMode(this.focusMode);
                localStorage.setItem('pdf-reader-focus-mode', this.focusMode.toString());
                this.hideSettingsDropdown();
                
                analyticsCallback('focus_mode_toggled', {
                    bookId: BOOK_CONFIG.id,
                    focusMode: this.focusMode,
                    timestamp: new Date().toISOString()
                });
            }
            
            applyFocusMode(enabled) {
                if (enabled) {
                    this.elements.bottomToolbar.classList.add('hidden');
                    this.elements.readingProgress.classList.add('hidden');
                } else {
                    this.elements.bottomToolbar.classList.remove('hidden');
                    this.elements.readingProgress.classList.remove('hidden');
                }
            }
            
            // Distraction Blocking functionality
            toggleDistractionBlocking() {
                this.distractionBlocking = !this.distractionBlocking;
                this.applyDistractionBlocking(this.distractionBlocking);
                localStorage.setItem('pdf-reader-distraction-block', this.distractionBlocking.toString());
                this.hideSettingsDropdown();
                
                analyticsCallback('distraction_blocking_toggled', {
                    bookId: BOOK_CONFIG.id,
                    distractionBlocking: this.distractionBlocking,
                    timestamp: new Date().toISOString()
                });
            }
            
            applyDistractionBlocking(enabled) {
                if (enabled) {
                    this.enableDistractionBlocking();
                } else {
                    this.disableDistractionBlocking();
                }
            }
            
            enableDistractionBlocking() {
                // Request notification permission and block them
                if ('Notification' in window) {
                    if (Notification.permission === 'granted') {
                        // Override notification constructor to block new notifications
                        this.originalNotification = window.Notification;
                        window.Notification = function() {
                            console.log('Notification blocked by PDF Reader');
                            return { close: () => {} };
                        };
                    } else if (Notification.permission !== 'denied') {
                        Notification.requestPermission().then(permission => {
                            if (permission === 'granted') {
                                this.originalNotification = window.Notification;
                                window.Notification = function() {
                                    console.log('Notification blocked by PDF Reader');
                                    return { close: () => {} };
                                };
                            }
                        });
                    }
                }
                
                // Block common distraction shortcuts
                this.blockDistractionShortcuts = true;
                
                // Set focus reminder title
                this.updateTabTitle();
                
                // Prevent tab switching warnings
                this.enableTabSwitchWarning();
            }
            
            disableDistractionBlocking() {
                // Restore original notification constructor
                if (this.originalNotification) {
                    window.Notification = this.originalNotification;
                    this.originalNotification = null;
                }
                
                // Unblock shortcuts
                this.blockDistractionShortcuts = false;
                
                // Restore original title
                document.title = this.originalTitle;
                
                // Disable tab switch warning
                this.disableTabSwitchWarning();
            }
            
            enableTabSwitchWarning() {
                this.beforeUnloadHandler = (e) => {
                    if (this.distractionBlocking) {
                        e.preventDefault();
                        e.returnValue = 'Are you sure you want to leave your reading session?';
                        return 'Are you sure you want to leave your reading session?';
                    }
                };
                window.addEventListener('beforeunload', this.beforeUnloadHandler);
            }
            
            disableTabSwitchWarning() {
                if (this.beforeUnloadHandler) {
                    window.removeEventListener('beforeunload', this.beforeUnloadHandler);
                    this.beforeUnloadHandler = null;
                }
            }
            
            handleVisibilityChange() {
                if (this.distractionBlocking) {
                    if (document.hidden) {
                        this.isTabActive = false;
                        document.title = 'üìñ Come back to your reading!';
                        
                        // Track distraction
                        analyticsCallback('tab_switched_away', {
                            bookId: BOOK_CONFIG.id,
                            page: this.currentPage,
                            timestamp: new Date().toISOString()
                        });
                    } else {
                        this.isTabActive = true;
                        this.updateTabTitle();
                        
                        // Track return
                        analyticsCallback('tab_switched_back', {
                            bookId: BOOK_CONFIG.id,
                            page: this.currentPage,
                            timestamp: new Date().toISOString()
                        });
                    }
                }
            }
            
            updateTabTitle() {
                if (this.distractionBlocking && this.isTabActive) {
                    const progress = this.totalPages > 0 ? Math.round((this.currentPage / this.totalPages) * 100) : 0;
                    document.title = `üìñ ${BOOK_CONFIG.title} (${progress}% - Page ${this.currentPage})`;
                } else if (!this.distractionBlocking) {
                    document.title = this.originalTitle;
                }
            }
            
            // Share functionality
            shareReader() {
                const shareData = {
                    title: BOOK_CONFIG.title,
                    text: `Reading "${BOOK_CONFIG.title}" - Page ${this.currentPage} of ${this.totalPages}`,
                    url: window.location.href
                };
                
                if (navigator.share) {
                    // Use native share API if available
                    navigator.share(shareData).catch(err => {
                        console.log('Error sharing:', err);
                        this.fallbackShare(shareData);
                    });
                } else {
                    this.fallbackShare(shareData);
                }
                
                this.hideSettingsDropdown();
                
                analyticsCallback('share_clicked', {
                    bookId: BOOK_CONFIG.id,
                    page: this.currentPage,
                    timestamp: new Date().toISOString()
                });
            }
            
            fallbackShare(shareData) {
                // Fallback share options
                const shareText = encodeURIComponent(shareData.text);
                const shareUrl = encodeURIComponent(shareData.url);
                
                const shareOptions = [
                    { name: 'Copy Link', action: 'copyToClipboard' },
                    { name: 'WhatsApp', url: `https://wa.me/?text=${shareText}%20${shareUrl}` },
                    { name: 'Twitter', url: `https://twitter.com/intent/tweet?text=${shareText}&url=${shareUrl}` },
                    { name: 'Facebook', url: `https://www.facebook.com/sharer/sharer.php?u=${shareUrl}` }
                ];
                
                const shareHtml = `
                    <div class="modal-content">
                        <h3>Share Reader</h3>
                        <div class="modal-buttons" style="flex-direction: column; gap: 10px;">
                            ${shareOptions.map(option => 
                                option.url ? 
                                `<a href="${option.url}" target="_blank" class="btn" style="text-decoration: none;">${option.name}</a>` :
                                `<button class="btn" onclick="reader.copyToClipboard('${shareData.url}')">${option.name}</button>`
                            ).join('')}
                            <button class="btn" onclick="reader.hideExitModal()">Close</button>
                        </div>
                    </div>
                `;
                
                this.elements.exitModal.innerHTML = shareHtml;
                this.elements.exitModal.style.display = 'block';
            }
            
            copyToClipboard(text) {
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(text).then(() => {
                        alert('Link copied to clipboard!');
                    }).catch(() => {
                        this.fallbackCopy(text);
                    });
                } else {
                    this.fallbackCopy(text);
                }
                this.hideExitModal();
            }
            
            fallbackCopy(text) {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    alert('Link copied to clipboard!');
                } catch (err) {
                    alert('Could not copy link. Please copy manually: ' + text);
                }
                document.body.removeChild(textArea);
            }
            
            exitAnyway() {
                // Close the reader or redirect
                if (window.parent !== window) {
                    // If in iframe, try to communicate with parent
                    window.parent.postMessage('close_reader', '*');
                } else {
                    // If standalone, go back or close
                    if (window.history.length > 1) {
                        window.history.back();
                    } else {
                        window.close();
                    }
                }
            }
            
            
            // Keyboard navigation
            handleKeyboard(e) {
                // Block distraction shortcuts if enabled
                if (this.blockDistractionShortcuts) {
                    const blockedKeys = [
                        'F12', // Developer tools
                        'F5',  // Refresh
                        'Tab'  // Tab switching (when combined with Ctrl)
                    ];
                    
                    if (blockedKeys.includes(e.key) || 
                        (e.ctrlKey && (e.key === 'r' || e.key === 'R' || e.key === 't' || e.key === 'T' || 
                                      e.key === 'w' || e.key === 'W' || e.key === 'n' || e.key === 'N' ||
                                      e.key === 'Tab'))) {
                        e.preventDefault();
                        console.log('Distraction shortcut blocked:', e.key);
                        return;
                    }
                }
                
                // Prevent navigation if modal is open
                if (this.elements.exitModal.style.display === 'block' || 
                    this.elements.breakAd.style.display === 'block') {
                    return;
                }
                
                switch(e.key) {
                    case 'ArrowLeft':
                    case 'PageUp':
                        e.preventDefault();
                        this.previousPage();
                        break;
                    case 'ArrowRight':
                    case 'PageDown':
                    case ' ':
                        e.preventDefault();
                        this.nextPage();
                        break;
                    case 'Home':
                        e.preventDefault();
                        this.goToPage(1);
                        break;
                    case 'End':
                        e.preventDefault();
                        this.goToPage(this.totalPages);
                        break;
                    case '+':
                    case '=':
                        e.preventDefault();
                        this.zoomIn();
                        break;
                    case '-':
                        e.preventDefault();
                        this.zoomOut();
                        break;
                    case 'f':
                    case 'F11':
                        e.preventDefault();
                        this.toggleFullscreen();
                        break;
                    case 'Escape':
                        if (this.isFullscreen) {
                            this.toggleFullscreen();
                        } else {
                            this.handleBackButton();
                        }
                        break;
                    case '0':
                        e.preventDefault();
                        this.smoothZoomToFit();
                        break;
                    case '1':
                        e.preventDefault();
                        this.smoothZoomTo(1.0);
                        break;
                    case '2':
                        e.preventDefault();
                        this.smoothZoomTo(2.0);
                        break;
                    case 'h':
                    case 'H':
                        if (!e.ctrlKey) {
                            e.preventDefault();
                            this.toggleToolbars();
                        }
                        break;
                }
            }
        }
        
        // Inline Service Worker for Offline Support
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Create service worker as blob URL
                const swCode = `
                    // PDF Reader Service Worker for Offline Caching
                    const CACHE_NAME = 'pdf-reader-v1.0.1';
                    const CACHE_ASSETS = [
                        './',
                        '${window.location.pathname}',
                        'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js',
                        'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js'
                    ];

                    // Install event - cache core assets
                    self.addEventListener('install', (event) => {
                        console.log('Service Worker: Installing...');
                        
                        event.waitUntil(
                            caches.open(CACHE_NAME)
                                .then((cache) => {
                                    console.log('Service Worker: Caching core assets');
                                    return cache.addAll(CACHE_ASSETS);
                                })
                                .then(() => {
                                    console.log('Service Worker: Core assets cached');
                                    return self.skipWaiting();
                                })
                                .catch((error) => {
                                    console.error('Service Worker: Cache installation failed', error);
                                })
                        );
                    });

                    // Activate event - clean up old caches
                    self.addEventListener('activate', (event) => {
                        console.log('Service Worker: Activating...');
                        
                        event.waitUntil(
                            caches.keys()
                                .then((cacheNames) => {
                                    return Promise.all(
                                        cacheNames.map((cacheName) => {
                                            if (cacheName !== CACHE_NAME) {
                                                console.log('Service Worker: Deleting old cache', cacheName);
                                                return caches.delete(cacheName);
                                            }
                                        })
                                    );
                                })
                                .then(() => {
                                    console.log('Service Worker: Activated');
                                    return self.clients.claim();
                                })
                        );
                    });

                    // Fetch event - serve cached content when offline
                    self.addEventListener('fetch', (event) => {
                        const request = event.request;
                        
                        // Skip non-GET requests
                        if (request.method !== 'GET') {
                            return;
                        }
                        
                        // Handle PDF files specially
                        if (request.url.endsWith('.pdf')) {
                            event.respondWith(
                                caches.match(request)
                                    .then((cachedResponse) => {
                                        if (cachedResponse) {
                                            console.log('Service Worker: Serving cached PDF', request.url);
                                            return cachedResponse;
                                        }
                                        
                                        // Fetch and cache PDF for future use
                                        return fetch(request)
                                            .then((response) => {
                                                // Check if response is valid
                                                if (!response || response.status !== 200 || response.type !== 'basic') {
                                                    return response;
                                                }
                                                
                                                // Clone response for caching
                                                const responseToCache = response.clone();
                                                
                                                caches.open(CACHE_NAME)
                                                    .then((cache) => {
                                                        console.log('Service Worker: Caching PDF', request.url);
                                                        cache.put(request, responseToCache);
                                                    });
                                                
                                                return response;
                                            })
                                            .catch((error) => {
                                                console.error('Service Worker: PDF fetch failed', error);
                                                return new Response('PDF not available offline');
                                            });
                                    })
                            );
                            return;
                        }
                        
                        // Handle other requests with cache-first strategy
                        event.respondWith(
                            caches.match(request)
                                .then((cachedResponse) => {
                                    // Return cached version if available
                                    if (cachedResponse) {
                                        console.log('Service Worker: Serving cached resource', request.url);
                                        return cachedResponse;
                                    }
                                    
                                    // Fetch from network
                                    return fetch(request)
                                        .then((response) => {
                                            // Check if response is valid
                                            if (!response || response.status !== 200 || response.type !== 'basic') {
                                                return response;
                                            }
                                            
                                            // Clone response for caching
                                            const responseToCache = response.clone();
                                            
                                            // Cache the response
                                            caches.open(CACHE_NAME)
                                                .then((cache) => {
                                                    // Only cache same-origin requests
                                                    if (request.url.startsWith(self.location.origin)) {
                                                        console.log('Service Worker: Caching resource', request.url);
                                                        cache.put(request, responseToCache);
                                                    }
                                                });
                                            
                                            return response;
                                        })
                                        .catch((error) => {
                                            console.error('Service Worker: Fetch failed', error);
                                            
                                            // Return offline fallback for HTML requests
                                            if (request.headers.get('accept') && request.headers.get('accept').includes('text/html')) {
                                                return caches.match('${window.location.pathname}');
                                            }
                                            
                                            // Return empty response for other failed requests
                                            return new Response('Resource not available offline', {
                                                status: 503,
                                                statusText: 'Service Unavailable'
                                            });
                                        });
                                })
                        );
                    });

                    // Handle messages from main thread
                    self.addEventListener('message', (event) => {
                        console.log('Service Worker: Message received', event.data);
                        
                        if (event.data && event.data.type === 'SKIP_WAITING') {
                            self.skipWaiting();
                        }
                        
                        if (event.data && event.data.type === 'CACHE_PDF') {
                            const pdfUrl = event.data.url;
                            event.waitUntil(
                                caches.open(CACHE_NAME)
                                    .then((cache) => {
                                        console.log('Service Worker: Manually caching PDF', pdfUrl);
                                        return cache.add(pdfUrl);
                                    })
                                    .then(() => {
                                        event.ports[0].postMessage({ success: true });
                                    })
                                    .catch((error) => {
                                        console.error('Service Worker: Manual PDF cache failed', error);
                                        event.ports[0].postMessage({ success: false, error: error.message });
                                    })
                            );
                        }
                    });
                `;
                
                // Create blob URL for service worker
                const swBlob = new Blob([swCode], { type: 'application/javascript' });
                const swUrl = URL.createObjectURL(swBlob);
                
                // Register the service worker
                navigator.serviceWorker.register(swUrl)
                    .then((registration) => {
                        console.log('Service Worker registered successfully:', registration.scope);
                        
                        // Check for updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // Show update notification
                                    if (reader) {
                                        reader.showNotification('App updated! Refresh to use new version.', 'info', 5000);
                                    }
                                }
                            });
                        });
                        
                        // Clean up blob URL after registration
                        URL.revokeObjectURL(swUrl);
                    })
                    .catch((error) => {
                        console.error('Service Worker registration failed:', error);
                        URL.revokeObjectURL(swUrl);
                    });
            });
        }

        // Initialize the PDF Reader when page loads
        let reader;
        document.addEventListener('DOMContentLoaded', () => {
            reader = new PDFReader();
            
            // Cache current PDF for offline access
            if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                const messageChannel = new MessageChannel();
                messageChannel.port1.onmessage = (event) => {
                    if (event.data.success) {
                        console.log('PDF cached for offline access');
                    } else {
                        console.error('PDF caching failed:', event.data.error);
                    }
                };
                
                navigator.serviceWorker.controller.postMessage({
                    type: 'CACHE_PDF',
                    url: PDF_URL
                }, [messageChannel.port2]);
            }
        });
    </script>
</body>
</html>